From 8144e80c975e78a14d86fb1c6c102a2235b4ce7e Mon Sep 17 00:00:00 2001
From: Fedor <fedor@mail.ru>
Date: Thu, 10 Mar 2022 20:43:59 +0200
Subject: [PATCH] rust 0111

---
 src/bootstrap/bootstrap.py        |   2 +-
 src/doc/embedded-book             |   2 +-
 src/libstd/build.rs               |   1 +
 src/libstd/sys/windows/c.rs       |  66 +++++++++++++------
 src/libstd/sys/windows/condvar.rs | 131 +++++++++++++++++++++++++++++++-------
 src/libstd/sys/windows/fs.rs      |  96 +++++++++++++++++++++-------
 src/libstd/sys/windows/rwlock.rs  | 114 ++++++++++++++++++++++++++++++---
 src/rustllvm/PassWrapper.cpp      |   2 +
 8 files changed, 339 insertions(+), 75 deletions(-)

diff --git a/src/bootstrap/bootstrap.py b/src/bootstrap/bootstrap.py
index 8af7aa4..4c92d29 100644
--- a/src/bootstrap/bootstrap.py
+++ b/src/bootstrap/bootstrap.py
@@ -678,7 +678,7 @@ class RustBuild(object):
         run(["git", "submodule", "-q", "sync", module],
             cwd=self.rust_root, verbose=self.verbose)
         run(["git", "submodule", "update",
-            "--init", "--recursive", "--progress", module],
+            "--init", "--recursive", module],
             cwd=self.rust_root, verbose=self.verbose)
         run(["git", "reset", "-q", "--hard"],
             cwd=module_path, verbose=self.verbose)
diff --git a/src/libstd/build.rs b/src/libstd/build.rs
index 726c273..1b0cbfd 100644
--- a/src/libstd/build.rs
+++ b/src/libstd/build.rs
@@ -42,6 +42,7 @@ fn main() {
         println!("cargo:rustc-link-lib=resolv");
     } else if target.contains("windows") {
         println!("cargo:rustc-link-lib=advapi32");
+        println!("cargo:rustc-link-lib=ntdll");
         println!("cargo:rustc-link-lib=ws2_32");
         println!("cargo:rustc-link-lib=userenv");
     } else if target.contains("fuchsia") {
diff --git a/src/libstd/sys/windows/c.rs b/src/libstd/sys/windows/c.rs
index 518eccf..85cf416 100644
--- a/src/libstd/sys/windows/c.rs
+++ b/src/libstd/sys/windows/c.rs
@@ -7,7 +7,7 @@
 use crate::os::raw::{c_int, c_uint, c_ulong, c_long, c_longlong, c_ushort, c_char};
 #[cfg(target_arch = "x86_64")]
 use crate::os::raw::c_ulonglong;
-use crate::ptr;
+//use crate::ptr;
 
 use libc::{wchar_t, size_t, c_void};
 
@@ -45,6 +45,7 @@ pub type LPCSTR = *const CHAR;
 pub type LPCVOID = *const c_void;
 pub type LPCWSTR = *const WCHAR;
 pub type LPDWORD = *mut DWORD;
+pub type LPLONG = *mut LONG;
 pub type LPHANDLE = *mut HANDLE;
 pub type LPOVERLAPPED = *mut OVERLAPPED;
 pub type LPPROCESS_INFORMATION = *mut PROCESS_INFORMATION;
@@ -62,7 +63,7 @@ pub type LPWSABUF = *mut WSABUF;
 pub type LPWSAOVERLAPPED = *mut c_void;
 pub type LPWSAOVERLAPPED_COMPLETION_ROUTINE = *mut c_void;
 
-pub type PCONDITION_VARIABLE = *mut CONDITION_VARIABLE;
+//pub type PCONDITION_VARIABLE = *mut CONDITION_VARIABLE;
 pub type PLARGE_INTEGER = *mut c_longlong;
 pub type PSRWLOCK = *mut SRWLOCK;
 
@@ -209,10 +210,10 @@ pub const INFINITE: DWORD = !0;
 
 pub const DUPLICATE_SAME_ACCESS: DWORD = 0x00000002;
 
-pub const CONDITION_VARIABLE_INIT: CONDITION_VARIABLE = CONDITION_VARIABLE {
+/*pub const CONDITION_VARIABLE_INIT: CONDITION_VARIABLE = CONDITION_VARIABLE {
     ptr: ptr::null_mut(),
 };
-pub const SRWLOCK_INIT: SRWLOCK = SRWLOCK { ptr: ptr::null_mut() };
+pub const SRWLOCK_INIT: SRWLOCK = SRWLOCK { ptr: ptr::null_mut() };*/
 
 pub const DETACHED_PROCESS: DWORD = 0x00000008;
 pub const CREATE_NEW_PROCESS_GROUP: DWORD = 0x00000200;
@@ -259,7 +260,7 @@ pub struct ipv6_mreq {
     pub ipv6mr_interface: c_uint,
 }
 
-pub const VOLUME_NAME_DOS: DWORD = 0x0;
+//pub const VOLUME_NAME_DOS: DWORD = 0x0;
 pub const MOVEFILE_REPLACE_EXISTING: DWORD = 1;
 
 pub const FILE_BEGIN: DWORD = 0;
@@ -463,8 +464,8 @@ pub type LPPROGRESS_ROUTINE = crate::option::Option<unsafe extern "system" fn(
     lpData: LPVOID,
 ) -> DWORD>;
 
-#[repr(C)]
-pub struct CONDITION_VARIABLE { pub ptr: LPVOID }
+/*#[repr(C)]
+pub struct CONDITION_VARIABLE { pub ptr: LPVOID }*/
 #[repr(C)]
 pub struct SRWLOCK { pub ptr: LPVOID }
 #[repr(C)]
@@ -989,6 +990,21 @@ pub struct timeval {
     pub tv_usec: c_long,
 }
 
+pub type NTSTATUS = LONG;
+
+#[repr(C)]
+union IO_STATUS_BLOCK_u {
+    Status: NTSTATUS,
+    Pointer: LPVOID,
+}
+
+#[repr(C)]
+pub struct IO_STATUS_BLOCK {
+    u: IO_STATUS_BLOCK_u,
+    Information: ULONG_PTR,
+}
+pub type PIO_STATUS_BLOCK = *mut IO_STATUS_BLOCK;
+
 extern "system" {
     pub fn WSAStartup(wVersionRequested: WORD,
                       lpWSAData: LPWSADATA) -> c_int;
@@ -1297,6 +1313,17 @@ extern "system" {
     pub fn HeapAlloc(hHeap: HANDLE, dwFlags: DWORD, dwBytes: SIZE_T) -> LPVOID;
     pub fn HeapReAlloc(hHeap: HANDLE, dwFlags: DWORD, lpMem: LPVOID, dwBytes: SIZE_T) -> LPVOID;
     pub fn HeapFree(hHeap: HANDLE, dwFlags: DWORD, lpMem: LPVOID) -> BOOL;
+    pub fn CreateSemaphoreW(lpSemaphoreAttributes: LPSECURITY_ATTRIBUTES, lInitialCount: LONG, lMaximumCount: LONG, lpName: LPCWSTR) -> HANDLE;
+    pub fn ReleaseSemaphore(hSemaphore: HANDLE, lReleaseCount: LONG, lpPreviousCount: LPLONG) -> BOOL;
+    pub fn InterlockedExchangeAdd(Addend: *mut LONG, Value: LONG) -> LONG;
+    pub fn SetEvent(hEvent: HANDLE) -> BOOL;
+    pub fn ResetEvent(hEvent: HANDLE) -> BOOL;
+    pub fn InterlockedIncrement(Addend: *mut LONG) -> LONG;
+    pub fn NtSetInformationFile(hFile: HANDLE, IoStatusBlock: PIO_STATUS_BLOCK, FileInformation: LPVOID, Length: ULONG, FileInformationClass: UINT) -> NTSTATUS;
+    //pub fn SetFilePointer(hFile: HANDLE, lDistanceToMove: LONG, lpDistanceToMoveHigh:  *mut LONG, dwMoveMethod: DWORD) -> DWORD;
+    pub fn NtQueryObject(Handle: HANDLE, ObjectInformationClass: UINT, ObjectInformation: LPCWSTR, ObjectInformationLength: ULONG, ReturnLength: *mut ULONG) -> NTSTATUS;
+    pub fn QueryDosDeviceW(lpDeviceName: LPCWSTR, lpTargetPath: LPWSTR, ucchMax: DWORD) -> DWORD;
+    pub fn GetLogicalDriveStringsW(nBufferLength: DWORD, lpBuffer: LPWSTR) -> DWORD;
 }
 
 // Functions that aren't available on every version of Windows that we support,
@@ -1307,14 +1334,15 @@ compat_fn! {
     pub fn CreateSymbolicLinkW(_lpSymlinkFileName: LPCWSTR,
                                _lpTargetFileName: LPCWSTR,
                                _dwFlags: DWORD) -> BOOLEAN {
-        SetLastError(ERROR_CALL_NOT_IMPLEMENTED as DWORD); 0
+        //SetLastError(ERROR_CALL_NOT_IMPLEMENTED as DWORD); 0
+        panic!("CreateSymbolicLinkW")
     }
-    pub fn GetFinalPathNameByHandleW(_hFile: HANDLE,
+    /*pub fn GetFinalPathNameByHandleW(_hFile: HANDLE,
                                      _lpszFilePath: LPCWSTR,
                                      _cchFilePath: DWORD,
                                      _dwFlags: DWORD) -> DWORD {
-        SetLastError(ERROR_CALL_NOT_IMPLEMENTED as DWORD); 0
-    }
+         SetLastError(ERROR_CALL_NOT_IMPLEMENTED as DWORD); 0
+    }*/
     pub fn SetThreadStackGuarantee(_size: *mut c_ulong) -> BOOL {
         SetLastError(ERROR_CALL_NOT_IMPLEMENTED as DWORD); 0
     }
@@ -1322,7 +1350,7 @@ compat_fn! {
                                 lpThreadDescription: LPCWSTR) -> HRESULT {
         SetLastError(ERROR_CALL_NOT_IMPLEMENTED as DWORD); E_NOTIMPL
     }
-    pub fn SetFileInformationByHandle(_hFile: HANDLE,
+    /*pub fn SetFileInformationByHandle(_hFile: HANDLE,
                     _FileInformationClass: FILE_INFO_BY_HANDLE_CLASS,
                     _lpFileInformation: LPVOID,
                     _dwBufferSize: DWORD) -> BOOL {
@@ -1341,25 +1369,25 @@ compat_fn! {
     pub fn WakeAllConditionVariable(ConditionVariable: PCONDITION_VARIABLE)
                                     -> () {
         panic!("condition variables not available")
-    }
+    }*/
     pub fn AcquireSRWLockExclusive(SRWLock: PSRWLOCK) -> () {
         panic!("rwlocks not available")
     }
-    pub fn AcquireSRWLockShared(SRWLock: PSRWLOCK) -> () {
+    /*pub fn AcquireSRWLockShared(SRWLock: PSRWLOCK) -> () {
         panic!("rwlocks not available")
-    }
+    }*/
     pub fn ReleaseSRWLockExclusive(SRWLock: PSRWLOCK) -> () {
         panic!("rwlocks not available")
     }
-    pub fn ReleaseSRWLockShared(SRWLock: PSRWLOCK) -> () {
+    /*pub fn ReleaseSRWLockShared(SRWLock: PSRWLOCK) -> () {
         panic!("rwlocks not available")
-    }
+    }*/
     pub fn TryAcquireSRWLockExclusive(SRWLock: PSRWLOCK) -> BOOLEAN {
         panic!("rwlocks not available")
     }
-    pub fn TryAcquireSRWLockShared(SRWLock: PSRWLOCK) -> BOOLEAN {
+    /*pub fn TryAcquireSRWLockShared(SRWLock: PSRWLOCK) -> BOOLEAN {
         panic!("rwlocks not available")
-    }
+    }*/
 }
 
 #[cfg(all(target_env = "gnu", feature = "backtrace"))]
diff --git a/src/libstd/sys/windows/condvar.rs b/src/libstd/sys/windows/condvar.rs
index 62835ea..faf5e49 100644
--- a/src/libstd/sys/windows/condvar.rs
+++ b/src/libstd/sys/windows/condvar.rs
@@ -1,55 +1,140 @@
 use crate::cell::UnsafeCell;
 use crate::sys::c;
-use crate::sys::mutex::{self, Mutex};
-use crate::sys::os;
+use crate::sys::mutex::Mutex;
+use crate::ptr;
 use crate::time::Duration;
 
-pub struct Condvar { inner: UnsafeCell<c::CONDITION_VARIABLE> }
+const WAKEUP_MODE_NONE: i32 = 0;
+const WAKEUP_MODE_ONE: u32 = 0x40000000;
+const WAKEUP_MODE_ALL: u32 = 0x80000000;
+const WAKEUP_MODE_MASK: u32 = WAKEUP_MODE_ONE | WAKEUP_MODE_ALL;
+const SLEEPERS_COUNT_MASK: u32 = !WAKEUP_MODE_MASK;
+
+pub struct Condvar { sleepersCountAndWakeupMode_: UnsafeCell<i32>,
+                     sleepWakeupSemaphore_: UnsafeCell<c::HANDLE>,
+                     wakeOneEvent_: UnsafeCell<c::HANDLE>,
+                     wakeAllEvent_: UnsafeCell<c::HANDLE>,
+}
 
 unsafe impl Send for Condvar {}
 unsafe impl Sync for Condvar {}
 
 impl Condvar {
     pub const fn new() -> Condvar {
-        Condvar { inner: UnsafeCell::new(c::CONDITION_VARIABLE_INIT) }
+        Condvar {
+                  sleepersCountAndWakeupMode_: UnsafeCell::new(WAKEUP_MODE_NONE),
+                  sleepWakeupSemaphore_: UnsafeCell::new(ptr::null_mut()),
+                  wakeOneEvent_: UnsafeCell::new(ptr::null_mut()),
+                  wakeAllEvent_: UnsafeCell::new(ptr::null_mut()),
+                }
     }
 
-    #[inline]
-    pub unsafe fn init(&mut self) {}
+    pub unsafe fn init(&mut self) {
+        *self.sleepWakeupSemaphore_.get() = c::CreateSemaphoreW(ptr::null_mut(), 1, 1, ptr::null_mut());
+        assert!(*self.sleepWakeupSemaphore_.get() != ptr::null_mut());
+        *self.wakeOneEvent_.get() = c::CreateEventW(ptr::null_mut(), c::FALSE, c::FALSE, ptr::null_mut());
+        assert!(*self.wakeOneEvent_.get() != ptr::null_mut());
+        *self.wakeAllEvent_.get() = c::CreateEventW(ptr::null_mut(), c::TRUE, c::FALSE, ptr::null_mut());
+        assert!(*self.wakeAllEvent_.get() != ptr::null_mut());
+    }
 
-    #[inline]
     pub unsafe fn wait(&self, mutex: &Mutex) {
-        let r = c::SleepConditionVariableSRW(self.inner.get(),
-                                             mutex::raw(mutex),
-                                             c::INFINITE,
-                                             0);
-        debug_assert!(r != 0);
+        Condvar::wait_timeout(self, mutex, Duration::from_secs(1000 * 365 * 86400));
     }
 
     pub unsafe fn wait_timeout(&self, mutex: &Mutex, dur: Duration) -> bool {
-        let r = c::SleepConditionVariableSRW(self.inner.get(),
-                                             mutex::raw(mutex),
-                                             super::dur2timeout(dur),
-                                             0);
-        if r == 0 {
-            debug_assert_eq!(os::errno() as usize, c::ERROR_TIMEOUT as usize);
-            false
+        let result = c::WaitForSingleObject(*self.sleepWakeupSemaphore_.get(), c::INFINITE);
+        assert!(result == c::WAIT_OBJECT_0);
+        let mut wcwm: u32 = c::InterlockedIncrement(self.sleepersCountAndWakeupMode_.get()) as u32;
+        assert!((wcwm & WAKEUP_MODE_MASK) == 0);
+        let mut success = c::ReleaseSemaphore(*self.sleepWakeupSemaphore_.get(), 1, ptr::null_mut());
+        assert!(success != 0);
+        mutex.unlock();
+        let handeles = [*self.wakeOneEvent_.get(), *self.wakeAllEvent_.get()];
+        let waitResult = c::WaitForMultipleObjects(2, handeles.as_ptr(), c::FALSE, super::dur2timeout(dur));
+
+        let sub: i32;
+        if waitResult == c::WAIT_OBJECT_0 {
+           sub = 1 | WAKEUP_MODE_ONE as i32;
         } else {
-            true
+           sub = 1;
         }
+        
+        wcwm = (c::InterlockedExchangeAdd(self.sleepersCountAndWakeupMode_.get(), -sub) - sub) as u32;
+
+        let wakeupMode = wcwm & WAKEUP_MODE_MASK;
+        let sleepersCount = wcwm & SLEEPERS_COUNT_MASK;
+
+        let mut releaseSleepWakeupSemaphore = false;
+
+        if waitResult == c::WAIT_OBJECT_0 {
+            releaseSleepWakeupSemaphore = true;
+        } else if waitResult == c::WAIT_TIMEOUT && wakeupMode == WAKEUP_MODE_ONE && sleepersCount == 0 {
+            success = c::ResetEvent(*self.wakeOneEvent_.get());
+            assert!(success != 0);
+            *self.sleepersCountAndWakeupMode_.get() = WAKEUP_MODE_NONE;
+            releaseSleepWakeupSemaphore = true;
+        } else if wakeupMode == WAKEUP_MODE_ALL && sleepersCount == 0 {
+            success = c::ResetEvent(*self.wakeAllEvent_.get());
+            assert!(success != 0);
+            *self.sleepersCountAndWakeupMode_.get() = WAKEUP_MODE_NONE;
+            releaseSleepWakeupSemaphore = true;
+        } else if waitResult == c::WAIT_TIMEOUT && super::dur2timeout(dur) != c::INFINITE ||
+                  (waitResult == c::WAIT_OBJECT_0 + 1 &&wakeupMode == WAKEUP_MODE_ALL) {
+        } else {
+            panic!("invalid wakeup condition");
+        }
+
+        if releaseSleepWakeupSemaphore {
+            success = c::ReleaseSemaphore(*self.sleepWakeupSemaphore_.get(), 1, ptr::null_mut());
+            assert!(success != 0);
+        }
+
+        mutex.lock();
+
+        if waitResult == c::WAIT_TIMEOUT {
+           c::SetLastError(c::ERROR_TIMEOUT);
+           return false;
+        }
+
+        true 
     }
 
     #[inline]
     pub unsafe fn notify_one(&self) {
-        c::WakeConditionVariable(self.inner.get())
+         Condvar::wakeup(self, WAKEUP_MODE_ONE, *self.wakeOneEvent_.get());
     }
 
     #[inline]
     pub unsafe fn notify_all(&self) {
-        c::WakeAllConditionVariable(self.inner.get())
+         Condvar::wakeup(self, WAKEUP_MODE_ALL, *self.wakeAllEvent_.get());
     }
 
     pub unsafe fn destroy(&self) {
-        // ...
+         assert!(*self.sleepersCountAndWakeupMode_.get() == 0);
+         let mut r = c::CloseHandle(*self.sleepWakeupSemaphore_.get());
+         assert!(r != 0);
+         r = c::CloseHandle(*self.wakeOneEvent_.get());
+         assert!(r != 0);
+         r = c::CloseHandle(*self.wakeAllEvent_.get());
+         assert!(r != 0);
     }
+
+    unsafe fn wakeup(&self, wakeupMode: u32, wakeEvent: c::HANDLE) {
+        let result = c::WaitForSingleObject(*self.sleepWakeupSemaphore_.get(), c::INFINITE);
+        assert!(result == c::WAIT_OBJECT_0);
+        let wcwm: u32 = c::InterlockedExchangeAdd(self.sleepersCountAndWakeupMode_.get(),
+                                             wakeupMode as i32) as u32;
+        let sleepersCount = wcwm & SLEEPERS_COUNT_MASK;
+        if sleepersCount > 0 {
+            let success = c::SetEvent(wakeEvent);
+            assert!(success != 0);
+        } else {
+            *self.sleepersCountAndWakeupMode_.get() = WAKEUP_MODE_NONE;
+            let success = c::ReleaseSemaphore(*self.sleepWakeupSemaphore_.get(), 1, ptr::null_mut());
+            assert!(success != 0);
+        }
+
+    }
+
 }
diff --git a/src/libstd/sys/windows/fs.rs b/src/libstd/sys/windows/fs.rs
index 4ebbb07..4d13342 100644
--- a/src/libstd/sys/windows/fs.rs
+++ b/src/libstd/sys/windows/fs.rs
@@ -1,5 +1,6 @@
 use crate::os::windows::prelude::*;
 
+use crate::ffi::{OsStr};
 use crate::ffi::OsString;
 use crate::fmt;
 use crate::io::{self, Error, SeekFrom};
@@ -278,13 +279,19 @@ impl File {
             EndOfFile: size as c::LARGE_INTEGER,
         };
         let size = mem::size_of_val(&info);
-        cvt(unsafe {
-            c::SetFileInformationByHandle(self.handle.raw(),
-                                          c::FileEndOfFileInfo,
-                                          &mut info as *mut _ as *mut _,
-                                          size as c::DWORD)
-        })?;
-        Ok(())
+        unsafe {
+           let mut io: c::IO_STATUS_BLOCK = mem::zeroed();
+           if c::NtSetInformationFile(self.handle.raw(),
+                                      &mut io as *mut _ as *mut _,
+                                      &mut info as *mut _ as *mut _,
+                                      size as c::DWORD,
+                                      20) == 0 {
+              Ok(())
+           }
+           else {
+              Err(crate::io::Error::last_os_error())
+           }
+        }
     }
 
     pub fn file_attr(&self) -> io::Result<FileAttr> {
@@ -395,8 +402,7 @@ impl File {
                      (*info).SubstituteNameLength / 2,
                      false)
                 },
-                _ => return Err(io::Error::new(io::ErrorKind::Other,
-                                               "Unsupported reparse point type"))
+                _ => return Err(crate::io::Error::last_os_error())
             };
             let subst_ptr = path_buffer.offset(subst_off as isize);
             let mut subst = slice::from_raw_parts(subst_ptr, subst_len as usize);
@@ -418,13 +424,20 @@ impl File {
             FileAttributes: perm.attrs,
         };
         let size = mem::size_of_val(&info);
-        cvt(unsafe {
-            c::SetFileInformationByHandle(self.handle.raw(),
-                                          c::FileBasicInfo,
-                                          &mut info as *mut _ as *mut _,
-                                          size as c::DWORD)
-        })?;
-        Ok(())
+
+        unsafe {
+           let mut io: c::IO_STATUS_BLOCK = mem::zeroed();
+           if c::NtSetInformationFile(self.handle.raw(),
+                                      &mut io as *mut _ as *mut _,
+                                      &mut info as *mut _ as *mut _,
+                                      size as c::DWORD,
+                                      4) == 0 {
+              Ok(())
+           }
+           else {
+              Err(crate::io::Error::last_os_error())
+           }
+        }
     }
 }
 
@@ -699,12 +712,51 @@ pub fn set_perm(p: &Path, perm: FilePermissions) -> io::Result<()> {
 }
 
 fn get_path(f: &File) -> io::Result<PathBuf> {
-    super::fill_utf16_buf(|buf, sz| unsafe {
-        c::GetFinalPathNameByHandleW(f.handle.raw(), buf, sz,
-                                     c::VOLUME_NAME_DOS)
-    }, |buf| {
-        PathBuf::from(OsString::from_wide(buf))
-    })
+   const MAX_PATH: usize = 1024;
+   const MAXSIZE: usize = MAX_PATH+4;
+
+   unsafe {
+      let mut drives = [0u16; MAX_PATH];
+      let mut path = [0u16; MAXSIZE];
+      let mut path2 = [0u16; MAX_PATH];
+      let mut sz: c::DWORD=MAXSIZE as u32;
+      if c::NtQueryObject(f.handle.raw(),1,&mut path as *mut _ as *mut _,sz,&mut sz as *mut _ as *mut _) == 0 {
+         sz=*&path[0] as u32;
+         let mut i=4;
+         while path[i] != 0 && i<sz as usize+4{
+            i+=1;
+         }
+         sz=i as u32;
+         i=0;
+         let mut s=4;
+         c::GetLogicalDriveStringsW((MAX_PATH-1) as u32, &mut drives as *mut _ as *mut _);
+         let mut j;
+         while drives[i] != 0 {
+             drives[i+2] = 0;
+             c::QueryDosDeviceW(&mut drives[i] as *mut _ as *mut _,&mut path2 as *mut _ as *mut _, MAX_PATH as u32);
+             j=0;
+             while path2[j] != 0 {
+                j+=1;
+             }
+             if OsString::from_wide(&path2[0..j]) == OsString::from_wide(&path[4..j+4]) {
+                path[j-2]='\\' as u16;
+                path[j-1]='\\' as u16;
+                path[j]='?' as u16;
+                path[j+1]='\\' as u16;
+                path[j+2]=drives[i];
+                path[j+3]=drives[i+1];
+                s=j-2; 
+                break;
+             }
+             i+=4;
+         }
+         testf(OsString::from_wide(&path[s..sz as usize]));
+         Ok(PathBuf::from(OsString::from_wide(&path[s..sz as usize])))
+      }
+      else {
+         Err(crate::io::Error::last_os_error())
+      }
+   }
 }
 
 pub fn canonicalize(p: &Path) -> io::Result<PathBuf> {
diff --git a/src/libstd/sys/windows/rwlock.rs b/src/libstd/sys/windows/rwlock.rs
index ef57562..4bd64ac 100644
--- a/src/libstd/sys/windows/rwlock.rs
+++ b/src/libstd/sys/windows/rwlock.rs
@@ -1,42 +1,138 @@
 use crate::cell::UnsafeCell;
+use crate::mem::{MaybeUninit};
+use crate::sync::atomic::{AtomicUsize, Ordering};
 use crate::sys::c;
 
-pub struct RWLock { inner: UnsafeCell<c::SRWLOCK> }
+pub struct RWLock {
+    lock: AtomicUsize,
+    held: UnsafeCell<bool>,
+}
 
 unsafe impl Send for RWLock {}
 unsafe impl Sync for RWLock {}
 
 impl RWLock {
     pub const fn new() -> RWLock {
-        RWLock { inner: UnsafeCell::new(c::SRWLOCK_INIT) }
+        RWLock {
+            lock: AtomicUsize::new(0),
+            held: UnsafeCell::new(false),
+            }
     }
     #[inline]
     pub unsafe fn read(&self) {
-        c::AcquireSRWLockShared(self.inner.get())
+                let re = self.remutex();
+                (*re).lock();
+                if !self.flag_locked() {
+                    (*re).unlock();
+                    panic!("cannot recursively lock a mutex");
+                }
     }
     #[inline]
     pub unsafe fn try_read(&self) -> bool {
-        c::TryAcquireSRWLockShared(self.inner.get()) != 0
+                let re = self.remutex();
+                if !(*re).try_lock() {
+                    false
+                } else if self.flag_locked() {
+                    true
+                } else {
+                    (*re).unlock();
+                    false
+                }
     }
     #[inline]
     pub unsafe fn write(&self) {
-        c::AcquireSRWLockExclusive(self.inner.get())
+                RWLock::read(&self);
+                /*let re = self.remutex();
+                (*re).lock();
+                if !self.flag_locked() {
+                    (*re).unlock();
+                    panic!("cannot recursively lock a mutex");
+                }*/
     }
     #[inline]
     pub unsafe fn try_write(&self) -> bool {
-        c::TryAcquireSRWLockExclusive(self.inner.get()) != 0
+                RWLock::try_read(&self)
+                /*let re = self.remutex();
+                if !(*re).try_lock() {
+                    false
+                } else if self.flag_locked() {
+                    true
+                } else {
+                    (*re).unlock();
+                    false
+                }*/
     }
     #[inline]
     pub unsafe fn read_unlock(&self) {
-        c::ReleaseSRWLockShared(self.inner.get())
+        *self.held.get() = false;
+        (*self.remutex()).unlock();
     }
     #[inline]
     pub unsafe fn write_unlock(&self) {
-        c::ReleaseSRWLockExclusive(self.inner.get())
+        RWLock::read_unlock(&self)
+    }
+
+    #[inline]
+    pub unsafe fn destroy(&self) {
+        match self.lock.load(Ordering::SeqCst) {
+            0 => {}
+            n => { Box::from_raw(n as *mut ReentrantMutex).destroy(); }
+        }
+    }
+
+    unsafe fn remutex(&self) -> *mut ReentrantMutex {
+        match self.lock.load(Ordering::SeqCst) {
+            0 => {}
+            n => return n as *mut _,
+        }
+        let mut re = box ReentrantMutex::uninitialized();
+        re.init();
+        let re = Box::into_raw(re);
+        match self.lock.compare_and_swap(0, re as usize, Ordering::SeqCst) {
+            0 => re,
+            n => { Box::from_raw(re).destroy(); n as *mut _ }
+        }
+    }
+
+    unsafe fn flag_locked(&self) -> bool {
+        if *self.held.get() {
+            false
+        } else {
+            *self.held.get() = true;
+            true
+        }
+
+    }
+}
+            
+pub struct ReentrantMutex { inner: UnsafeCell<MaybeUninit<c::CRITICAL_SECTION>> }
+
+unsafe impl Send for ReentrantMutex {}
+unsafe impl Sync for ReentrantMutex {}
+
+impl ReentrantMutex {
+    pub fn uninitialized() -> ReentrantMutex {
+        ReentrantMutex { inner: UnsafeCell::new(MaybeUninit::uninit()) }
+    }
+
+    pub unsafe fn init(&mut self) {
+        c::InitializeCriticalSection((&mut *self.inner.get()).as_mut_ptr());
+    }
+
+    pub unsafe fn lock(&self) {
+        c::EnterCriticalSection((&mut *self.inner.get()).as_mut_ptr());
     }
 
     #[inline]
+    pub unsafe fn try_lock(&self) -> bool {
+        c::TryEnterCriticalSection((&mut *self.inner.get()).as_mut_ptr()) != 0
+    }
+
+    pub unsafe fn unlock(&self) {
+        c::LeaveCriticalSection((&mut *self.inner.get()).as_mut_ptr());
+    }
+
     pub unsafe fn destroy(&self) {
-        // ...
+        c::DeleteCriticalSection((&mut *self.inner.get()).as_mut_ptr());
     }
 }
diff --git a/src/rustllvm/PassWrapper.cpp b/src/rustllvm/PassWrapper.cpp
index 319c66a21..6bd19ea 100644
--- a/src/rustllvm/PassWrapper.cpp
+++ b/src/rustllvm/PassWrapper.cpp
@@ -23,6 +23,8 @@
 
 #include "llvm-c/Transforms/PassManagerBuilder.h"
 
+#include "llvm/InitializePasses.h"
+
 using namespace llvm;
 using namespace llvm::legacy;
 
-- 
2.8.2.windows.1

